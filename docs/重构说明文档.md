# PDF转Markdown样式识别系统重构说明

## 📋 重构概述

本次重构将PDF转Markdown的样式识别系统从"脆弱的字符串匹配 + 魔法阈值"升级为"基于视觉统计的可解释语义推断系统"。

**核心原则**：
- ✅ 保守重构：保留现有文件结构与数据流
- ✅ 多特征评分：不依赖单一特征（如fontName字符串）
- ✅ 相对判断：所有判断基于"相对正文基准"
- ✅ 可解释性：所有判断结果可说明原因
- ✅ 可配置性：所有阈值和权重可参数化

---

## 🔧 修改文件清单

### 1. 新增文件

#### `build/models/StyleConfidence.js`
**职责**：表示文本样式的置信度分数（0-1范围）

**关键方法**：
- `toWordFormat(threshold)`: 将置信度转换为WordFormat（当超过阈值时）
- `static combine(...confidences)`: 合并多个置信度分数

**数据结构**：
```javascript
{
  bold: 0~1,    // 粗体置信度
  italic: 0~1  // 斜体置信度
}
```

#### `build/models/HeaderScore.js`
**职责**：表示LineItem作为标题的置信度分数，包含特征元数据

**关键方法**：
- `static create(features)`: 基于多特征创建HeaderScore

**特征权重**（在`HeaderScore.create`中定义）：
- `fontSizeRatio`: 0.35（最重要）
- `verticalSpacing`: 0.20
- `isStandalone`: 0.15
- `positionOnPage`: 0.10
- `repetitionPattern`: 0.10
- `isUppercase`: 0.05（弱信号）
- `fontFamilyDiff`: 0.05

#### `build/util/style-detection-config.js`
**职责**：集中管理所有样式检测的配置参数

**配置项**：
- `styleConfidence`: 样式置信度阈值
- `fontStyleWeights`: 字体样式检测权重
- `headerDetection`: 标题检测配置
- `widthComparison`: 字符宽度比较配置

---

### 2. 重构文件

#### `build/models/transformations/text-item/CalculateGlobalStats.js`

**修改理由**：
- 原实现仅依赖`fontName.includes('bold')`字符串匹配
- 无法处理中文PDF、字体名不规范等情况
- 缺少视觉特征（如字符宽度）的支持

**主要变更**：

1. **引入多特征字体样式评分**（第58-78行）
   - 新增`calculateFontWidthStats()`: 计算每个字体的平均字符宽度
   - 新增`calculateStyleConfidence()`: 多特征评分函数

2. **特征优先级**（在`calculateStyleConfidence`中）：
   ```javascript
   // 1. FontDescriptor.FontWeight (40%权重) - 最高优先级
   // 2. 字符宽度比较 (35%权重) - 同字体族不同权重对比
   // 3. 相对正文宽度 (20%权重) - 宽度/正文平均宽度
   // 4. 字体名匹配 (5%权重) - 弱信号，仅作后备
   ```

3. **向后兼容**：
   - 保留`fontToFormats` Map（输出格式名）
   - 新增`fontToStyleProfile` Map（存储StyleConfidence，用于可解释性）
   - 新增`bodyAvgWidthPerChar`（用于宽度比较）

**关键算法**：

```javascript
// 伪代码：多特征样式评分
function calculateStyleConfidence(fontObj, fontId, ...) {
  let boldScore = 0, italicScore = 0
  
  // 特征1: FontDescriptor.FontWeight (最高优先级)
  if (fontObj.fontDescriptor?.FontWeight >= 600) {
    boldScore += 0.40
  }
  
  // 特征2: 字符宽度比较
  if (currentWidth / bodyWidth >= 1.1) {
    boldScore += 0.35 * normalizedWidthRatio
  }
  
  // 特征3: 相对正文宽度
  if (relativeWidth > 1.1) {
    boldScore += 0.20 * normalizedRelativeWidth
  }
  
  // 特征4: 字体名匹配（后备）
  if (fontName.includes('bold')) {
    boldScore += 0.05
  }
  
  return new StyleConfidence(boldScore, italicScore)
}
```

---

#### `build/models/transformations/line-item/DetectHeaders.js`

**修改理由**：
- 原实现依赖固定阈值（如`1/4`比例）
- 仅按高度排序分配标题级别，缺少上下文分析
- 无法区分"标题"和"加粗正文"

**主要变更**：

1. **多特征加权评分**（第17-137行）
   - 为每个LineItem计算`HeaderScore`
   - 使用7个特征的综合评分

2. **特征说明**：
   - `fontSizeRatio`: fontSize / bodyFontSize（最重要，35%权重）
   - `verticalSpacing`: 行前/行后垂直间距（20%权重）
   - `isStandalone`: 是否独占一行（15%权重）
   - `positionOnPage`: 页面位置（顶部=高分，10%权重）
   - `repetitionPattern`: 该fontSize出现频率（10%权重）
   - `isUppercase`: 是否全大写（弱信号，5%权重）
   - `fontFamilyDiff`: 字体是否与正文不同（5%权重）

3. **聚类而非排序**（第119-140行）：
   - 不再直接按高度排序分配级别
   - 使用`clusterHeadersByFontSize()`按fontSize聚类
   - 同一fontSize映射到同一标题级别（H1-H4 max）

4. **语义边界清晰**：
   - `fontSize ≈ bodyFontSize && isBold` → 加粗正文（**text**）
   - `fontSize > bodyFontSize && isStandalone` → 标题候选
   - 禁止仅凭"加粗 + 大号"直接判定为标题

**关键算法**：

```javascript
// 伪代码：标题评分
function calculateHeaderScore(item, ...) {
  const fontSizeRatio = item.height / bodyHeight
  
  // 特征1: fontSizeRatio（最重要）
  if (fontSizeRatio < 1.15) return HeaderScore(0) // 太小，不是标题
  
  // 特征2-7: 其他特征
  const features = {
    fontSizeRatio,
    verticalSpacing: calculateVerticalSpacing(...),
    isStandalone: isLineStandalone(...),
    positionOnPage: (maxY - item.y) / (maxY - minY),
    repetitionPattern: occurrence / maxOccurrence,
    isUppercase: text === text.toUpperCase(),
    fontFamilyDiff: item.font !== bodyFont
  }
  
  return HeaderScore.create(features) // 加权求和，归一化到[0,1]
}

// 聚类算法
function clusterHeadersByFontSize(candidates, bodyHeight, maxLevel) {
  // 1. 按fontSize分组（容差0.5）
  // 2. 按fontSizeRatio排序（大→小）
  // 3. 分配级别（H1-H4 max）
  // 4. 返回 fontSize → level 映射
}
```

---

#### `build/models/markdown/BlockType.js`

**修改理由**：
- 原实现强制`disableInlineFormats=true`，导致标题内的加粗/斜体丢失
- Markdown规范允许标题内使用内联格式（如`### **Bold Title**`）

**主要变更**：

1. **标题内联格式保留**（第74-111行）
   - 所有标题（H1-H6）的`toText()`方法中，`disableInlineFormats`从`true`改为`false`
   - 允许标题中保留`**bold**`和`*italic*`格式

2. **Markdown兼容性**：
   - `### **Title**` ✅ 合法
   - `### *Title*` ✅ 合法
   - `### **Title** *Subtitle*` ✅ 合法

---

## 📊 数据流变化

### 原数据流
```
PDF → TextItem → CalculateGlobalStats → fontToFormats (Map<fontId, formatName>)
                                         ↓
                                    DetectHeaders (高度排序)
                                         ↓
                                    BlockType.toText (disableInlineFormats=true)
```

### 新数据流
```
PDF → TextItem → CalculateGlobalStats → fontToFormats (Map<fontId, formatName>) [向后兼容]
                                         fontToStyleProfile (Map<fontId, StyleConfidence>) [新增]
                                         bodyAvgWidthPerChar [新增]
                                         ↓
                                    DetectHeaders (多特征评分 + 聚类)
                                         ↓
                                    fontSizeToHeaderLevel (Map<fontSize, level>) [新增]
                                         ↓
                                    BlockType.toText (disableInlineFormats=false) [修复]
```

---

## 🎯 关键改进点

### 1. 加粗检测改进

**原实现问题**：
- ❌ 仅依赖`fontName.includes('bold')`
- ❌ 无法处理中文PDF
- ❌ 无法处理字体名不规范的情况

**新实现优势**：
- ✅ 多特征评分（FontWeight、宽度比较、相对宽度、字体名）
- ✅ 支持视觉检测（字符宽度比较）
- ✅ 可解释性（每个特征贡献度可追踪）

### 2. 标题检测改进

**原实现问题**：
- ❌ 固定阈值（`1/4`比例）
- ❌ 仅按高度排序
- ❌ 缺少上下文分析

**新实现优势**：
- ✅ 多特征加权评分（7个特征）
- ✅ 聚类而非排序（同一fontSize → 同一级别）
- ✅ 上下文感知（位置、间距、重复模式）
- ✅ 可配置阈值（`fontSizeRatioThreshold`等）

### 3. 格式保留改进

**原实现问题**：
- ❌ 标题内格式被强制禁用
- ❌ 无法保留标题中的加粗关键词

**新实现优势**：
- ✅ 标题内格式保留（`**bold**`、`*italic*`）
- ✅ Markdown规范兼容

---

## 🔍 可解释性支持

### StyleConfidence
每个字体样式判断都包含置信度分数，可以解释：
- 为什么判定为粗体？（boldScore = 0.75）
- 哪些特征贡献了分数？（FontWeight: 0.40, WidthComparison: 0.35）

### HeaderScore
每个标题判断都包含特征元数据：
```javascript
{
  score: 0.82,
  features: {
    fontSizeRatio: 1.5,      // 字体大小是正文的1.5倍
    verticalSpacing: 2.3,    // 垂直间距较大
    isStandalone: true,      // 独占一行
    positionOnPage: 0.8,     // 位于页面上方
    repetitionPattern: 0.6,  // 该fontSize出现频率中等
    isUppercase: false,
    fontFamilyDiff: true     // 字体与正文不同
  }
}
```

---

## ⚙️ 配置参数说明

所有配置在`build/util/style-detection-config.js`中：

### 样式置信度阈值
```javascript
styleConfidence: {
  boldThreshold: 0.5,    // 粗体置信度阈值
  italicThreshold: 0.5,   // 斜体置信度阈值
}
```

### 字体样式检测权重
```javascript
fontStyleWeights: {
  fontDescriptorWeight: 0.40,  // FontDescriptor.FontWeight权重
  widthComparison: 0.35,        // 字符宽度比较权重
  bodyWidthRatio: 0.20,         // 相对正文宽度权重
  fontNameMatch: 0.05,          // 字体名匹配权重（弱）
}
```

### 标题检测配置
```javascript
headerDetection: {
  minScore: 0.4,                    // 最小HeaderScore阈值
  maxLevel: 4,                      // 最大标题级别（H1-H4）
  fontSizeRatioThreshold: 1.15,     // 最小fontSize/bodyFontSize
  verticalSpacingMultiplier: 1.5,   // 垂直间距归一化倍数
}
```

### 字符宽度比较配置
```javascript
widthComparison: {
  minSamples: 3,              // 最小样本数（用于宽度比较）
  widthRatioThreshold: 1.1,   // 粗体文本宽度阈值（通常宽10-20%）
}
```

---

## 🧪 验证场景

重构后的系统应能正确处理：

1. **中文PDF**（字体名不含Bold）
   - ✅ 通过字符宽度比较检测粗体
   - ✅ 通过FontDescriptor.FontWeight检测（如果可用）

2. **同字体族不同权重**
   - ✅ 通过宽度比较区分Regular和Bold变体

3. **标题中包含加粗关键词**
   - ✅ 标题内格式保留：`### **重要**标题`

4. **大号正文但无标题语义**
   - ✅ 通过`isStandalone`、`verticalSpacing`等特征区分

5. **封面页标题不影响正文结构**
   - ✅ 封面页的maxHeight文本单独处理为H1

---

## 📝 向后兼容性

### 保持的接口
- ✅ `fontToFormats` Map仍然存在（输出格式名）
- ✅ `globals`结构保持兼容
- ✅ 所有Transform类接口不变

### 新增的接口
- ✅ `fontToStyleProfile` Map（StyleConfidence，用于可解释性）
- ✅ `fontSizeToHeaderLevel` Map（标题级别映射）
- ✅ `bodyAvgWidthPerChar`（字符宽度统计）

---

## 🚀 使用示例

### 查看样式置信度
```javascript
const { fontToStyleProfile } = parseResult.globals
const confidence = fontToStyleProfile.get('g_d1')
console.log(`Bold confidence: ${confidence.bold}, Italic: ${confidence.italic}`)
```

### 查看标题级别映射
```javascript
const { fontSizeToHeaderLevel } = parseResult.globals
console.log('FontSize to HeaderLevel:', Array.from(fontSizeToHeaderLevel.entries()))
// 输出: [[18, 1], [16, 2], [14, 3], [12, 4]]
```

### 调整配置
```javascript
// 修改 build/util/style-detection-config.js
headerDetection: {
  minScore: 0.5,  // 提高阈值，更严格的标题检测
  maxLevel: 3,    // 只允许H1-H3
}
```

---

## 📚 相关文档

- `文本样式识别分析.md`: 原系统问题分析
- `PDF转Markdown逻辑原理.md`: 整体架构说明
- `build/util/style-detection-config.js`: 配置参数定义

---

## ✅ 重构完成清单

- [x] 重构CalculateGlobalStats：多特征字体样式评分
- [x] 重构DetectHeaders：多特征加权评分 + 聚类
- [x] 修复BlockType.js：标题内联格式保留
- [x] 引入StyleConfidence和HeaderScore数据结构
- [x] 添加可配置参数系统
- [x] 更新文档说明

---

## 🎓 总结

本次重构实现了从"脆弱的字符串匹配 + 魔法阈值"到"基于视觉统计的可解释语义推断系统"的升级，同时保持了向后兼容性和代码可维护性。所有判断都基于相对基准，所有阈值都可配置，所有结果都可解释。

