# PDF转Markdown文本样式识别分析

## 当前实现流程

### 1. PDF解析阶段（`build/util/pdf.js`）

从PDF中提取的文本信息：
- **位置信息**：`x`, `y` 坐标
- **尺寸信息**：`width`, `height`（文本高度）
- **文本内容**：`text`（字符串）
- **字体信息**：`fontName`（字体ID，如 `g_d0`, `g_d1` 等）

**关键点**：PDF.js只提供字体ID，不直接提供样式信息（如是否加粗、斜体等）

### 2. 全局统计阶段（`CalculateGlobalStats.js`）

#### 2.1 统计基准值
- `mostUsedHeight`：最常用的文本高度 → **作为正文高度基准**
- `mostUsedFont`：最常用的字体 → **作为正文字体基准**
- `maxHeight`：最大文本高度 → **用于识别标题**
- `mostUsedDistance`：最常用的行间距

#### 2.2 字体格式映射（`fontToFormats`）

**当前实现逻辑**（第60-78行）：
```javascript
// 通过字体名称（fontName）推断格式
const fontName = value.name.toLowerCase()
if (fontName.includes('bold') && (fontName.includes('oblique') || fontName.includes('italic'))) {
  format = WordFormat.BOLD_OBLIQUE  // 粗斜体
} else if (fontName.includes('bold')) {
  format = WordFormat.BOLD  // 粗体
} else if (fontName.includes('oblique') || fontName.includes('italic')) {
  format = WordFormat.OBLIQUE  // 斜体
} else if (fontName === maxHeightFont) {
  format = WordFormat.BOLD  // 最大高度字体也认为是粗体
}
```

**问题**：
1. **依赖字体名称**：如果PDF中字体名称不规范（如中文PDF、某些生成工具），可能无法识别
2. **逻辑简单**：只检查字符串包含关系，可能误判
3. **缺少字体权重信息**：没有使用PDF的字体权重（font-weight）属性

### 3. 标题检测阶段（`DetectHeaders.js`）

#### 3.1 检测策略（按优先级）

**策略1：基于最大高度的标题页检测**（第23-38行）
- 找到包含最大高度文本的页面（通常是封面）
- `maxHeight` → H1
- `min2ndLevelHeaderHeigthOnMaxPage` → H2

**策略2：基于目录的标题检测**（第40-55行）
- 如果存在目录（TOC），使用目录中提取的标题高度范围
- 匹配相同高度的文本项

**策略3：基于高度的标题分类**（第56-95行，无目录时）
- 收集所有大于正文高度的文本项
- 按高度降序排序
- 分配标题级别（H2-H6）

**策略4：基于格式的标题检测**（第97-129行）
- 检测全大写文本
- 检测不同字体的文本（`item.font !== mostUsedFont`）
- 检测有明显间距的文本

**问题**：
1. **高度阈值固定**：`min2ndLevelHeaderHeigthOnMaxPage = mostUsedHeight + ((maxHeight - mostUsedHeight) / 4)` 可能不适合所有文档
2. **字体差异检测简单**：只检查字体ID是否不同，不考虑字体族关系
3. **缺少上下文分析**：没有考虑标题的上下文特征（如位置、前后间距等）

### 4. 文本合并阶段（`CompactLines.js` + `LineConverter.js`）

#### 4.1 合并同一行的文本项
- 使用 `TextItemLineGrouper` 按Y坐标分组
- 使用 `LineConverter` 将同一行的文本项合并为 `LineItem`

#### 4.2 格式信息传递（`LineConverter.js`）
- 从 `fontToFormats` 映射中获取每个 `TextItem` 的格式
- 将格式信息传递给 `Word` 对象（第151-152行）

**关键代码**：
```javascript
const format = this.fontToFormats.get(textItems[0].font)
results.push(...this.itemsToWords(textItems, format))
```

### 5. Markdown生成阶段（`ToMarkdown.js` + `BlockType.js`）

#### 5.1 格式转换（`BlockType.js` 的 `linesToText` 函数）

**当前实现**（第23-60行）：
- 遍历每个 `Word`，检查其 `format` 属性
- 如果格式改变，关闭旧格式，开启新格式
- 使用 `WordFormat` 的 `startSymbol` 和 `endSymbol`（如 `**` 表示粗体）

**问题**：
1. **标题格式被禁用**：标题（H1-H6）在转换为Markdown时，`disableInlineFormats=true`（第75行），**丢失了标题内的加粗等格式**
2. **格式合并不智能**：相邻的相同格式可能被分开处理

## 当前实现的主要问题

### 1. 加粗检测问题

**问题1：依赖字体名称**
- PDF中字体名称可能不规范（如中文PDF、某些工具生成的PDF）
- 某些PDF可能使用字体族的不同变体，但名称不包含"bold"

**问题2：缺少字体权重信息**
- PDF.js可能提供字体权重信息，但当前代码没有使用
- 应该检查字体的 `font-weight` 或 `fontDescriptor` 属性

**问题3：没有视觉检测**
- 没有通过文本宽度/渲染宽度来判断是否加粗
- 加粗文本通常比普通文本更宽

### 2. 标题级别检测问题

**问题1：高度阈值固定**
- 使用固定的比例（1/4）可能不适合所有文档
- 某些文档可能有多个标题级别，但高度差异不明显

**问题2：缺少语义分析**
- 没有分析标题的语义特征（如位置、编号、样式等）
- 没有考虑标题的层级关系

**问题3：字体差异检测简单**
- 只检查字体ID是否不同，不考虑字体族关系
- 某些文档可能使用相同字体族的不同变体

### 3. 格式保留问题

**问题1：标题内格式丢失**
- 标题转换为Markdown时，`disableInlineFormats=true`，导致标题内的加粗、斜体等格式丢失

**问题2：格式合并不智能**
- 相邻的相同格式可能被分开处理，导致格式标记冗余

## 优化建议

### 1. 改进加粗检测

**方案1：使用PDF字体属性**
- 检查字体的 `fontDescriptor` 中的 `FontWeight` 属性
- 检查字体的 `subtype` 和 `baseFont` 属性

**方案2：视觉检测**
- 比较相同字符在不同字体下的宽度
- 加粗文本的宽度通常比普通文本宽约10-20%

**方案3：字体族分析**
- 分析字体族关系，识别同一字体族的粗体变体
- 例如：`Arial` 和 `Arial-Bold` 的关系

### 2. 改进标题检测

**方案1：多特征融合**
- 结合高度、字体、位置、间距等多个特征
- 使用机器学习或规则引擎进行综合判断

**方案2：上下文分析**
- 分析标题前后的内容特征
- 考虑标题的编号、缩进等特征

**方案3：层级关系分析**
- 分析标题之间的层级关系
- 使用标题的嵌套结构来验证检测结果

### 3. 改进格式保留

**方案1：标题内格式保留**
- 修改 `BlockType.js` 中的标题转换逻辑，允许保留内联格式

**方案2：智能格式合并**
- 优化格式标记的合并逻辑，减少冗余标记

### 4. 其他优化

**方案1：字体信息增强**
- 从PDF中提取更多字体信息（如字体族、权重、样式等）
- 建立更完善的字体到格式的映射

**方案2：可配置的检测规则**
- 允许用户配置标题检测规则和格式映射规则
- 支持不同文档类型的自定义规则

## 代码位置总结

| 功能 | 文件位置 | 关键函数/类 | 行号 |
|------|---------|------------|------|
| PDF解析 | `build/util/pdf.js` | `parse()` | 23-426 |
| 字体提取 | `build/util/pdf.js` | `transport.commonObjs.get(fontId)` | 430 |
| 全局统计 | `build/models/transformations/text-item/CalculateGlobalStats.js` | `transform()` | 13-113 |
| 字体格式映射 | `build/models/transformations/text-item/CalculateGlobalStats.js` | 字体格式判断逻辑 | 60-78 |
| 标题检测 | `build/models/transformations/line-item/DetectHeaders.js` | `transform()` | 17-137 |
| 文本合并 | `build/models/LineConverter.js` | `compact()` | 19-66 |
| 格式转换 | `build/models/markdown/BlockType.js` | `linesToText()` | 23-60 |
| Markdown生成 | `build/models/transformations/ToMarkdown.js` | `transform()` | 19-133 |

## 关键代码片段

### 1. 字体格式映射（当前实现）

```javascript
// build/models/transformations/text-item/CalculateGlobalStats.js:60-78
this.fontMap.forEach(function (value, key) {
  fontIdToName.push(key + ' = ' + value.name)
  const fontName = value.name.toLowerCase()
  var format
  if (key === mostUsedFont) {
    format = null  // 正文字体，无格式
  } else if (fontName.includes('bold') && (fontName.includes('oblique') || fontName.includes('italic'))) {
    format = WordFormat.BOLD_OBLIQUE
  } else if (fontName.includes('bold')) {
    format = WordFormat.BOLD
  } else if (fontName.includes('oblique') || fontName.includes('italic')) {
    format = WordFormat.OBLIQUE
  } else if (fontName === maxHeightFont) {
    format = WordFormat.BOLD  // 最大高度字体也认为是粗体
  }
  if (format) {
    fontToFormats.set(key, format.name)
  }
})
```

### 2. 标题检测（高度阈值）

```javascript
// build/models/transformations/line-item/DetectHeaders.js:24
const min2ndLevelHeaderHeigthOnMaxPage = mostUsedHeight + ((maxHeight - mostUsedHeight) / 4)
```

### 3. 标题内格式被禁用

```javascript
// build/models/markdown/BlockType.js:75
H1: {
  toText (block) {
    return '# ' + linesToText(block.items, true)  // true = disableInlineFormats
  },
}
```

### 4. 格式转换逻辑

```javascript
// build/models/markdown/BlockType.js:23-60
function linesToText (lineItems, disableInlineFormats) {
  var text = ''
  var openFormat
  // ... 遍历words，根据format添加Markdown格式标记
  if (wordFormat && !openFormat && (!disableInlineFormats)) {
    openFormat = wordFormat
    text += openFormat.startSymbol  // 如 '**' 表示粗体
  }
  // ...
}
```

